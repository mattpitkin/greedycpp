WARNING: while making changes to code, make sure one can reproduce the
example test!!!

Overview
--------
Given a parameterized model h(x;p), whose physical variable is x and
parameterization p. From a collection of model evaluations at known at
training set points p_i, we have a training space

   { h(x_j;p_i) }

This training space fills up a matrix A. This routine finds a low-rank
approximation of A by a pivoted QR (aka greedy) decomposition. The output
are a collection of p_i (greedy parameter values), the orthonormal basis,
and an R matrix such that A = R * Q where the rows of Q are precisely the 
basis.


Requirements
------------
mpi
libconfig
hdf5 


Usage
-----

         -- serial mode --
1) edit greedy.cpp (see below)
2) run 'make Greedy'
3) run './greedy'


         -- mpi --
1) run 'make'
2) mpirun -np NUM_PROCS ./greedympi PARAM_FILE.cfg

run a simple test case with

mpirun -np 1 ./ greedympi example1/test1.cfg




Running on SuperMike2 with MPI
------------------------------
0) add the following to ~/.soft:
+Intel-13.0.0
@default
+gsl-1.15-Intel-13.0.0
@default
+openmpi-1.6.3-Intel-13.0.0
@default

and run 'resoft'

Next, do

1) open make file and replace mpi install command with

mpicxx -o greedympi greedy.cpp TrainingSet.cpp -I/usr/local/packages/gsl/1.15/Intel-13.0.0/include -L/usr/local/packages/gsl/1.15/Intel-13.0.0/lib -lgsl -lgslcblas -lm

2) run 'make'
3) open mpiGreedyQsub and set number of nodes.
4) run 'qsub mpiGreedyQsub' (this will print a jobID to screen)
5) monitor job with qstat jobID


Running without mpi
-------------------

comment out the following code 
1) include of mpi.h
2) GreedyWorker and GreedyMaster routines
3) MPI::Init and few lines which follow
4) MPI::Finalize()
5) GreedyWorker and GreedyMaster function calls within main() 


Troubleshooting
---------------
if gsl not found run

gsl-config --cflags --libs-without-cblas

and the output says what must be added to g++ for to compile and link. Standard spot is in /usr/libs or opt/local


possible optimization
---------------------
1) multiply all vectors by square root of weights so Euclidean inner product can be used.



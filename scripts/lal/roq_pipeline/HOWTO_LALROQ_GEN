
--- building the roq (linear and quadratic) on a single interval ---

Write me!



--- validations of greedy and eim data ---

1) Modify the SetupMultipleValidations.py script to validate an ROQ (data in the folder)

2) run ./mergeValidations, delete old folders
3) merge all validation files into a single one

>>> cat test.txt* > validations.txt [or skip this step, if the file sizes are too large]
>>> cat bad_points_test.txt* > ts_bad_points.txt
>>> rm bad_points_test.txt*

4) can check the worst validations in ipython

>>> x = np.loadtxt('validations.txt')  [x = np.loadtxt('test.txt0')]
>>> x.max(axis=0)

5) if there are bad points, enrich the basis (see bitbucket wiki).


--- resampling for a \delta f = constant (1/128, e.g.) ---

1) setup a directory for the new run

>>> mkdir df128

2) link to setup_new_quad.py, change settings and run in the folder

3) submit the job with roq.build.sh




--- exporting roq for LAL ---

1) change permissions on output files/folders so others can read them. 
>>> chmod -R a+r greedy_tidalEOB/ [from the most-top ROQ folder]
2) create a gather.sh file, which will make multiple calls to Michael's convert script




--- Using the pipeline: building the roq (linear and quadratic) on a multiple training intervals ---

see examples/seob_roq

workflow (linear): setup run directories -> run -> validate -> upsample -> validate upsampled 
workflow (quadratic): linear basis -> form quadratic TS -> run -> validate -> ...

Prerequisites: 

1) SAMPLER SCRIPT (random and deterministic)

   Write a script which takes parameter intervals and sampling information,
   and returns a text file of points, with each row containing a unique
   parameter sample (examples/seob_roq/generate_seob_points.py).

   Parameter intervals and sampling information should be given
   as a single input file, for example 

#chirpmass eta chi1 chi2                    <- parameter names
1.2  0.1  -1.0 -1.0                         <- lower value
17.0 0.25 .99  .99                          <- upper value
23   5   7  12                              <- points-per-dimension
det_power_0.5 det_power_2 det_lin det_lin   <- sampling strategy as a string


2) QUADRATURE

   Generate quadrature nodes/weights for each
   interval (examples/seob_roq/generate_seob_quadrature.py).

   For more complex cases, its advisable to use an adaptive quadrature
   rule which probably depends on the model and training interval and
   so a script can be used.

See: examples/seob_roq/frequency_intervals.input

3) INPUT FILE

   Setup a json file which can be used for input to SetupMultipleROQs.py
   (examples/seob_roq/seob_roq.input). 

Running: Once these 3 pieces are in place, run

                >>> SetupMultipleROQs.py

         to create run directory(s) with all the necessary pieces for an ROQ build.
         It may be helpful to write a script which creates the training set, 
         quadrature rules and input files (examples/seob_roq/setup_seob_roq.py) 

Validation: (i) Once the runs have finished, use SetupMultipleValidations.py as
            usual to validate. Most likely, only the details related
            to the random sampling will need to be changed.

            (ii) Submit all validation jobs to the queue

                >>> ./submit_all_jobs.sh

            (iii) After all jobs are completed, merge the results into 
            a singled directory. Concurrently, collect all bad points (large errors)
            into a single file, validations_full_range/ts_bad_points.txt. If 
            ts_bad_points.txt is non-empty you'll want to refine the basis with
            another greedy run. The training set can be taken to be the union
            of bad points plus the points in GreedyPoints.txt. This file is 
            created it/TS_IT.txt. All these things are done by running 

                >>> ./merge_validations.sh

Enrichment: A new, better basis can be built by 

            (i) Copying run_settings.cfg into the newly created 'it' directory.

            (ii) Edit the following keys found:
                    max_RB
                    output_dir
                    ts_file

            (iii) Submit a new greedy run with roq.build.sh

            (iv) Continue validate -> enrich -> validate -> ... until the basis 
                 is accurate enough.

TODO: FIXME: When upsampling, the string outdir occurs twice in the cfg file.
             As a result, the eim program will get two different paths (see 
             roq.build.sh and *.err *.out files in greedy_seob/roq_0/df4).

Upsample: Once the adaptive quadrature ROQ (basis + eim) has been validated,
          its time to upsampled onto a physical (detector) grid.

          The first task is to determine the grid spacing df. Do

                >>> generate_uniform_df.py

          to find the longest waveform (smallest chirp, largest q, spin aligned)
          in the training region. More information can be found in the email
          correspondance with Michael P ("selected df").

          Once a suitable df has been found, create a new directory directly under
          the ROQ output folder for the adaptive grid data and do

             >>> mkdir df128
             >>> ln -s /home/sfield/misc_notebooks_codes/greedycpp_helpers/setup_new_quad.py
             >>> ./setup_new_quad.py --min 20.0 --max 4096.0 --num 521729

          which will setup a new ROQ rundir using the specified grid (here df = 1/128)
          and using all of the same settings found in the adaptive grid's  *.cfg file.
          The greedy points are take to be the training set for the uniform grid ROQ build.


Quadratic: Use SetupQuadraticGreedy.py to setup a quadratic basis run directory
           complete with a cfg file and training points. Run the greedycpp code.

           Quadratic points should be created from uniform frequency grid.
